## Тестовое задание на должность "Разработчик NodeJS" Грин-АПИ

### Задание
1. Требуется разработать механизм асинхронной обработки HTTP запросов
2. Требуется использовать стек NodeJS, RabbitMQ
3. Требуется оформить в виде репозитория на Github
4. Требуется приложить инструкцию по локальному развертыванию проекта
5. Требуется реализовать логирование для целей отладки и мониторинга
6. Требуется разработать микросервис М1 для обработки входящих HTTP запросов
7. Требуется разработать микросервис М2 для обработки заданий из RabbitMQ

**Алгоритм работы:**
- Получаем HTTP запрос на уровне микросервиса М1.
- Транслируем HTTP запрос в очередь RabbitMQ. Запрос трансформируется в задание.
- Обрабатываем задание микросервисом М2 из очереди RabbitMQ.
- Помещаем результат обработки задания в RabbitMQ.
- Возвращаем результат HTTP запроса как результат выполнения задания из RabbitMQ.

### Установка и запуск

`npm ci` - установка зависимостей

`npm start -w m1` - запуск сервиса M1

`npm start -w m2` - запуск сервиса M2

**Предварительные требования:** запущенный сервиc RabbitMQ без авторизации на подключение. Адрес подключения к сервису задается в константах `RABBIT_URL`

Проверка работоспособности: запрос `GET /echo` должен вернуть в теле ответа JSON с заголовками запроса и двумя дополнительными свойствами `correlationId` и  `replyTo`.

### Общее описание работы

Сервис **M1** трансформирует Входящие HTTP запросы в задания и отправляет их брокеру в очередь сообщений с именем из константы `AMQP_QUEUE_NAME`. У сообщений устанавливаются параметры `correlationId` и  `replyTo`, содержащие уникальный идентификатор ответа и имя очереди в которую сервис **M2** должен отправить ответ.

Сервис **M2** слушает очередь с именем из константы `AMQP_QUEUE_NAME`. При получении сообщения сервис выполняет с ним работу и высылает ответ в очередь с именем из параметра `replyTo` входящего сообщения.

 ![image](https://github.com/alexmyt/GreenAPI-test/assets/37371343/9408d513-c4ab-495a-a0f2-70ea7f58debc)

### Примечания к выполненной работе

Так как нету четкого описания требования _"разработать механизм асинхронной обработки HTTP запросов"_, то реализована обработка всех без исключения запросов без использования каких-то веб-фреймворков. При реальной разработке этот вопрос требуется уточнить и выполнить реализацию в соответствии с требованиями.

Так как нету четкого определения  алгоритма трансформации запроса в задание, то реализована простая трансформация запроса в объект типа `Task`. Тип задания определяется на основании метода и url HTTP-запроса. Для запроса `GET /echo` создается задание `TaskType.ECHO`, в результате обработки возвращающее заголовки и тело текущего запроса.

### Микросервис M1

Логирование реализовано с использованием библиотеки Pino. Эта библиотека позволяет, при необходимости, настроить логирование в различные точки сбора логов, в том числе централизованные.

Работа с RabbitMQ реализована через класс `RabbitClient`. Алгоритм работы с классом:
1. Класс реализован с использованием паттерна Singleton, для получения экземпляра класса необходимо вызвать статический метод 
`RabbitClient.getInstance()`. 
2. Перед использованием экземпляр инициализируется вызовом асинхронного метода `initialize()`. Метод получает в качестве параметра экземпляр логера.

  В процессе инициализации выполняется алгоритм: 
  - создается экземпляр `EventEmitter` для обработки событий при получении ответов на отправленные сообщения;
  - создается соединение с сервером RabbitMQ по адресу из константы `RABBIT_URL`;
  - создаются отдельные каналы для отправки (produce) и получения (consume) сообщений;
  - канал для прослушивания сообщений связывается с очередью с рандомным именем для получения ответных сообщений от брокера;
  - запускается обработчик, который слушает сообщения в канале для ответных сообщений, и при появлении нового сообщения вызывает событие `EventEmitter.emit()` c именем `correlationId`. Обработчик реализован в классе `RabbitClientConsumer`.

3. Отправка сообщения брокеру реализовано через метод `produce()`. Сообщение отправляется в очередь с именем из константы `AMQP_QUEUE_NAME`. При отправке сообщению устанавливаются параметры:
  - `correlationId` - уникальный идентификатор, с которым должно вернуться ответное сообщение.
  - `replyTo` - имя очереди, в которую необходимо выслать ответное сообщение.

Метод возвращает промис который разрешается в значение с телом ответного сообщения.

### Микросервис M2

Сервис получает сообщения из очереди с именем из константы `AMQP_QUEUE_NAME`, обрабатывает и отсылает результат в очередь с именем из параметра `replyTo` входящего сообщения. У исходящего сообщения устанавливается параметр `correlationId` равный значению одноименного параметра из входящего сообщения.
